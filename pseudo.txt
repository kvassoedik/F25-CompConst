Lexer{
    file;
    unsigned start, pos;
    char* line;
    string acc;
}

scan() {
    step()
}

step() {
    while (getChar(1)) {
        pos++;
        char c;

        if (letter) continue;
        if (c == '.') {

        }
    }
    if (!fail) {
        linenum++;
        if (!comment.open || !comment.multiline) && (pos - start >= 0)
            processWord();
    }

    getline();
    if (eof)
        processWord();
    else
        processEndline();
}

processEndline() {
    if (comment.open && comment.multiline) {
        addToken(comment, pos)
        addNewlineToken()
    }
    addToken(endline)
}

processWord {
    addToken()
}

addToken {
    tk.span.start = start;
    tk.span.end = pos;
    if savestrings {
        tk.str = std::move(line.substr(start, pos));
    }
    start = pos + 1;
}

addNewlineToken {
    tk.span.start = start+1;
    tk.span.end = start+1;
}

processChar {
    switch() {
        case '.': {
            if (isAccumulated()) {
                if (isDigit(acc[0])) {
                    // This is a real literal
                    acc += c;
                    return;
                }
            } else {
                c2 = getChar(1);
                if (isDigit(c2)) {
                    // This is a real literal. Add both this dot and the following char and move on
                    acc += c;
                    acc += static_cast<unsigned char>(byte);
                    continue;
                } else {
                    addToken(dot)
                }
            }
            return;
        }
    }
}

isAccumulated() {
    return (pos - start >= 0);
}

bool getChar(offset, unsigned char ch&) {
    if (pos + offset < line.size()) {
        ch = line[pos+offset];
        return true;
    }

    if (!getline() || ) return false;


    return true;
}

void fastSeek(int off) {
    if (pos + off >= start)
}


///////////////////
Lexer{
	std::string saved;
    int savedStart, currTkStart_, pos;
    size_t savedIdx = 0;
    unsigned long lineNum;
}

getChar() {
	if (pos - savedStart + 1 > savedIdx)
		// get
		saved[savedIdx++] = c;
		return c;
	else {
		pos++;
		return saved[pos];
	}
}

stepBack(off) {
	if (pos - off > savedStart)
		pos -= off;
}

case ':': {
	unsigned char c2;
	if (getChar(c2)) {
		if ('=' == c2) {
            return addToken(assignment)
        }
		stepBack(1);
        // oh, you're not ":=", sorry for the trouble, going back :P
	}
    return addToken(COLON);
}
case '/': {
    unsigned char c2;
	if (getChar(c2)) {
        if ('/' == c2) {
            return addToken(COMMENT_ONELINE)
        }
        if ('*' == c2) {
            return addToken(COMMENT_OPEN)
        }
    }
    return addToken(DIVIDE)
}

checkCommentClose(c, unsigned char* c2 = nullptr) {
    if (c != '*') return false;

    unsigned char ch2;
    if (c2) {
        ch2 = *c2;
    } else {
        if (!getChar(*ch2)) return false;
    }
    if ('/' == c2) {
        return true
    }
    stepBack(1);
    return false
}

checkEndline() {

}

processEndline() {

}

addToken(tk, endPos = pos_, startPos = currTkStart_) {
    tk.span.line = lineNum_;
    tk.span.start = currTkStart_;
    tk.span.end = endPos;
    currTkStart_ = tk.span.end + 1;
#if SAVE_TOKEN_STRING
    tk._str = saved.substr(savedStart - tk.span.start, tk.span.end - tk.span.start + 1)
#endif
}

 if (comment_.isMultiline) {
    if (!checkCommentClose(c)) {
        continue;
    }
    addToken(COMMENT_BODY, pos - 2);
    addToken(COMMENT_CLOSE);
            } else {
                char endlineNum = processEndline(c);
                if (!endlineNum) {
                    continue;
                }
                // Endline has been hit, seek back to process the endline again after
                file_->seekg(-endlineNum, std::ios::cur);
                comment_.isStarted = false;
            }
